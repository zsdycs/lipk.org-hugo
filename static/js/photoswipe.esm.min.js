/*!
  * PhotoSwipe 5.0.0 - https://photoswipe.com
  * (c) 2021 Dmitry Semenov
  */
function t(t, i, s) { const h = document.createElement(i || "div"); return t && (h.className = t), s && s.appendChild(h), h } function i(t, i) { return t.x = i.x, t.y = i.y, void 0 !== i.id && (t.id = i.id), t } function s(t) { t.x = Math.round(t.x), t.y = Math.round(t.y) } function h(t, i) { const s = Math.abs(t.x - i.x), h = Math.abs(t.y - i.y); return Math.sqrt(s * s + h * h) } function e(t, i) { return t.x === i.x && t.y === i.y } function n(t, i, s) { return Math.min(Math.max(t, i), s) } function o(t, i, s) { let h = "translate3d(" + t + "px," + (i || 0) + "px,0)"; return void 0 !== s && (h += " scale3d(" + s + "," + s + ",1)"), h } function r(t, i, s, h) { t.style.transform = o(i, s, h) } function a(t, i, s, h) { t.style.transition = i ? i + " " + s + "ms " + (h || "cubic-bezier(.4,0,.22,1)") : "none" } function c(t) { return "decode" in t ? t.decode() : t.complete ? Promise.resolve(t) : new Promise(((i, s) => { t.onload = () => i(t), t.onerror = s })) } let l = !1; try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => { l = !0 } })) } catch (t) { } class p { constructor() { this.t = [] } add(t, i, s, h) { this.i(t, i, s, h) } remove(t, i, s, h) { this.i(t, i, s, h, !0) } removeAll() { this.t.forEach((t => { this.i(t.target, t.type, t.listener, t.passive, !0, !0) })), this.t = [] } i(t, i, s, h, e, n) { if (!t) return; const o = (e ? "remove" : "add") + "EventListener"; (i = i.split(" ")).forEach((i => { if (i) { n || (e ? this.t = this.t.filter((h => h.type !== i || h.listener !== s || h.target !== t)) : this.t.push({ target: t, type: i, listener: s, passive: h })); const r = !!l && { passive: h || !1 }; t[o](i, s, r) } })) } } class u { constructor(t) { this.slide = t, this.currZoomLevel = 1, this.center = {}, this.max = {}, this.min = {}, this.reset() } update(t) { this.currZoomLevel = t, this.slide.width ? (this.o("x"), this.o("y"), this.slide.pswp.dispatch("calcBounds", { slide: this.slide })) : this.reset() } o(t) { const i = this.slide["x" === t ? "width" : "height"] * this.currZoomLevel, s = "x" === t ? "Left" : "Top", h = this.slide.pswp.options["padding" + s] || 0, e = this.slide.panAreaSize[t]; this.center[t] = Math.round((e - i) / 2) + h, this.max[t] = i > e ? Math.round(e - i) + h : this.center[t], this.min[t] = i > e ? h : this.center[t] } reset() { this.center.x = 0, this.center.y = 0, this.max.x = 0, this.max.y = 0, this.min.x = 0, this.min.y = 0 } correctPan(t, i) { return n(i, this.max[t], this.min[t]) } } class d { constructor(t, i, s) { this.options = t, this.itemData = i, this.index = s } update(t, i, s) { this.elementSize = { x: t, y: i }, this.panAreaSize = s; const h = this.panAreaSize.x / this.elementSize.x, e = this.panAreaSize.y / this.elementSize.y; this.fit = Math.min(1, h < e ? h : e), this.fill = Math.min(1, h > e ? h : e), this.vFill = Math.min(1, e), this.initial = this.l(), this.secondary = this.p(), this.max = Math.max(this.initial, this.secondary, this.u()), this.min = Math.min(this.fit, this.initial, this.secondary) } m(t) { const i = this.options[t + "ZoomLevel"]; if (i) return "function" == typeof i ? i(this) : "fill" === i ? this.fill : "fit" === i ? this.fit : Number(i) } p() { let t = this.m("secondary"); return t || (t = Math.min(1, 2.5 * this.fit), t * this.elementSize.x > 3e3 && (t = 3e3 / this.elementSize.x), t) } l() { return this.m("initial") || this.fit } u() { const t = this.m("max"); return t || Math.max(1, 4 * this.fit) } } function m(t, i) { if (t.getViewportSizeFn) { const s = t.getViewportSizeFn(t, i); if (s) return s } return { x: document.documentElement.clientWidth, y: window.innerHeight } } function f(t, i) { return { x: i.x - (t.paddingLeft || 0) - (t.paddingRight || 0), y: i.y - (t.paddingTop || 0) - (t.paddingBottom || 0) } } function w(t, i, s) { t.style.width = i + "px", t.style.height = s + "px" } class g { constructor(t, i, s) { this.data = t, this.index = i, this.pswp = s, this.isActive = i === s.currIndex, this.currentResolution = 0, this.panAreaSize = {}, this.isFirstSlide = this.isActive && !s.opener.isOpen, this.zoomLevels = new d(s.options, t, i), this.pswp.dispatch("gettingData", { slide: this, data: this.data, index: i }), this.pan = { x: 0, y: 0 }, this.currZoomLevel = 1, this.width = Number(t.w), this.height = Number(t.h), this.bounds = new u(this) } setIsActive(t) { t && !this.isActive ? this.activate() : !t && this.isActive && this.deactivate() } append(i) { if (this.holderElement = i, this.data) { if (this.g(), this.container = t("pswp__zoom-wrap"), this.container.transformOrigin = "0 0", this.data.html) this.addSlideHTML(this.data.html); else if (this.data.src) { const i = this.data.msrc && this.isFirstSlide; this.placeholder = t("pswp__img pswp__img--placeholder", i ? "img" : "", this.container), i && (this.placeholder.decoding = "async", this.placeholder.alt = "", this.placeholder.src = this.data.msrc), this.placeholder.setAttribute("aria-hiden", "true"), this.pswp.dispatch("placeholderCreated", { placeholder: this.placeholder, slide: this }), this.image || this.preload(), this.isLoading = !0 } this.appendHeavy(), this.holderElement.innerHTML = "", this.holderElement.appendChild(this.container), this.zoomAndPanToInitial(), this.pswp.dispatch("firstZoomPan", { slide: this }), this.applyCurrentZoomPan(), this.pswp.dispatch("afterSetContent", { slide: this }), this.isActive && this.activate() } else this.holderElement.innerHTML = "" } preload() { this.image = t("pswp__img", "img"), this.image.src = this.data.src, this.data.srcset && (this.image.srcset = this.data.srcset), this.image.alt = this.data.alt || "", this.pswp.lazyLoader.addRecent(this.index), this._() } appendHeavy() { const { pswp: t } = this; !this.heavyAppended && t.opener.isOpen && !t.mainScroll.isShifted() && (this.isActive, 1) && (this.pswp.dispatch("appendHeavy", { slide: this }).defaultPrevented || (this.heavyAppended = !0, this.image && (this.v(), c(this.image).then((() => { this.M() })).catch((() => { this.M(!0) }))))) } v() { this.P || (this.container.appendChild(this.image), this.P = !0) } M(t) { this.v(), this.isLoading = !1, this.pswp.dispatch("loadComplete", { slide: this, isError: t }), this.placeholder && setTimeout((() => { this.placeholder && (this.placeholder.remove(), this.placeholder = null) }), 500), t && this.S() } S() { this.addSlideHTML(this.pswp.options.errorMsg); const t = this.container.querySelector(".pswp__error-msg a"); t && this.data.src && (t.href = this.data.src), this.loadError = !0, this.image = null, this.g(), this.setZoomLevel(1), this.panTo(0, 0), this.pswp.dispatch("loadError", { slide: this }) } addSlideHTML(t) { const { container: i } = this; t.tagName ? i.appendChild(t) : i.innerHTML = t, i.style.width = "100%", i.style.height = "100%", i.classList.add("pswp__zoom-wrap--html") } activate() { this.isActive = !0, this.appendHeavy(), this.pswp.dispatch("slideActivate", { slide: this }) } deactivate() { this.isActive = !1, this.zoomAndPanToInitial(), this.applyCurrentZoomPan(), this.pswp.dispatch("slideDeactivate", { slide: this }) } destroy() { this.pswp.dispatch("slideDestroy", { slide: this }) } resize() { this.g(), this.currZoomLevel !== this.zoomLevels.initial && this.isActive || (this.currentResolution = 0), this._(), this.zoomAndPanToInitial(), this.applyCurrentZoomPan() } _() { if (!this.data.src || !this.width) return; const t = this.currentResolution || this.zoomLevels.initial; if (!t) return; const i = Math.round(this.width * t), s = Math.round(this.height * t); this.placeholder && w(this.placeholder, i, s); const { image: h } = this; h && (w(h, i, s), (!h.dataset.largestUsedSize || i > h.dataset.largestUsedSize) && (h.sizes = i + "px", h.dataset.largestUsedSize = i), this.pswp.dispatch("imageSizeChange", { slide: this, width: i, height: s })) } getPlaceholder() { return this.placeholder } zoomTo(t, i, h, e) { const { pswp: o } = this; if (!this.isZoomable || o.mainScroll.isShifted()) return; o.animations.stopAllPan(), i || (i = o.getViewportCenterPoint()); const r = this.currZoomLevel; e || (t = n(t, this.zoomLevels.min, this.zoomLevels.max)), this.setZoomLevel(t), this.pan.x = this.calculateZoomToPanOffset("x", i, r), this.pan.y = this.calculateZoomToPanOffset("y", i, r), s(this.pan); const a = () => { this.T(t), this.applyCurrentZoomPan() }; h ? o.animations.startTransition({ isPan: !0, name: "zoomTo", target: this.container, transform: this.getCurrentTransform(), onComplete: a, duration: h, easing: o.options.easing }) : a() } toggleZoom(t) { this.zoomTo(this.currZoomLevel === this.zoomLevels.initial ? this.zoomLevels.secondary : this.zoomLevels.initial, t, this.pswp.options.zoomAnimationDuration) } setZoomLevel(t) { this.currZoomLevel = t, this.bounds.update(this.currZoomLevel) } calculateZoomToPanOffset(t, i, s) { const h = this.bounds.max[t] - this.bounds.min[t]; let e; if (0 === h) return this.bounds.center[t]; const n = this["x" === t ? "width" : "height"] * (s || this.currZoomLevel), { panPaddingRatio: o, panEdgeIsViewport: r } = this.pswp.options, a = this.panAreaSize[t] * o; let c; return c = !r && i[t] < a + this.pan[t] ? 0 : !r && i[t] > n + this.pan[t] - a ? 1 : (i[t] - this.bounds.min[t] - a) / (this.panAreaSize[t] - 2 * a), e = h * c + this.bounds.min[t], e = this.bounds.correctPan(t, e), e } panTo(t, i) { this.pan.x = this.bounds.correctPan("x", t), this.pan.y = this.bounds.correctPan("y", i), this.applyCurrentZoomPan() } isPannable() { return this.width && this.currZoomLevel > this.zoomLevels.fit } isZoomable() { return this.width > 0 } applyCurrentZoomPan() { this.C(this.pan.x, this.pan.y, this.currZoomLevel), this === this.pswp.currSlide && this.pswp.dispatch("zoomPanUpdate", { slide: this }) } zoomAndPanToInitial() { this.currZoomLevel = this.zoomLevels.initial, this.bounds.update(this.currZoomLevel), i(this.pan, this.bounds.center), this.pswp.dispatch("initialZoomPan", { slide: this }) } C(t, i, s) { s /= this.currentResolution || this.zoomLevels.initial, r(this.container, t, i, s) } g() { if (this.data.src && !this.loadError) { const { pswp: t } = this; i(this.panAreaSize, f(t.options, t.viewportSize)), this.zoomLevels.update(this.width, this.height, this.panAreaSize) } else this.width = 0, this.height = 0, this.zoomLevels.fit = 1, this.zoomLevels.vFill = 1, this.zoomLevels.initial = 1 } getCurrentTransform() { const t = this.currZoomLevel / (this.currentResolution || this.zoomLevels.initial); return o(this.pan.x, this.pan.y, t) } T(t) { t !== this.currentResolution && (this.currentResolution = t, this._(), this.pswp.dispatch("resolutionChanged")) } } class _ { constructor(t) { this.gestures = t, this.pswp = t.pswp, this.startPan = {} } start() { i(this.startPan, this.pswp.currSlide.pan), this.pswp.animations.stopAll() } change() { const { p1: t, prevP1: i, dragAxis: h, pswp: e } = this.gestures, { currSlide: n } = e; if ("y" === h && e.options.closeOnVerticalDrag && n.currZoomLevel <= n.zoomLevels.vFill && !this.gestures.isMultitouch) { const s = n.pan.y + (t.y - i.y); if (!e.dispatch("verticalDrag", { panY: s }).defaultPrevented) { this.D("y", s, .6); const t = 1 - Math.abs(this.I(n.pan.y)); e.applyBgOpacity(t), n.applyCurrentZoomPan() } } else { this.A("x") || (this.A("y"), s(n.pan), n.applyCurrentZoomPan()) } } end() { const { pswp: t, velocity: i } = this.gestures, { mainScroll: s } = t; let h = 0; if (t.animations.stopAll(), s.isShifted()) { const e = (s.x - s.getCurrSlideX()) / t.viewportSize.x; i.x < -.5 && e < 0 || i.x < .1 && e < -.5 ? (h = 1, i.x = Math.min(i.x, 0)) : (i.x > .5 && e > 0 || i.x > -.1 && e > .5) && (h = -1, i.x = Math.max(i.x, 0)), s.moveIndexBy(h, !0, i.x) } t.currSlide.currZoomLevel > t.currSlide.zoomLevels.max || this.gestures.isMultitouch ? this.gestures.zoomLevels.correctZoomPan() : (this.k("x"), this.k("y")) } k(t) { const { pswp: i } = this, { currSlide: s } = i, { velocity: h } = this.gestures, { pan: e, bounds: o } = s, r = e[t], a = i.bgOpacity < 1 && "y" === t, c = r + function (t, i) { return t * i / (1 - i) }(h[t], .995); if (a) { const t = this.I(r), s = this.I(c); if (t < 0 && s < -.4 || t > 0 && s > .4) return void i.close() } const l = o.correctPan(t, c); if (r === l) return; const p = l === c ? 1 : .82, u = i.bgOpacity, d = l - r; i.animations.startSpring({ name: "panGesture" + t, isPan: !0, start: r, end: l, velocity: h[t], dampingRatio: p, onUpdate: h => { if (a && i.bgOpacity < 1) { const t = 1 - (l - h) / d; i.applyBgOpacity(n(u + (1 - u) * t, 0, 1)) } e[t] = h, s.applyCurrentZoomPan() } }) } A(t) { const { p1: i, pswp: s, dragAxis: h, prevP1: e, isMultitouch: n } = this.gestures, { currSlide: o, mainScroll: r } = s, a = i[t] - e[t], c = r.x + a; if (!a) return; if ("x" === t && !o.isPannable() && !n) return r.moveTo(c, !0), !0; const { bounds: l } = o, p = o.pan[t] + a; if (s.options.allowPanToNext && "x" === h && "x" === t && !n) { const i = r.getCurrSlideX(), s = r.x - i, h = a > 0, e = !h; if (p > l.min[t] && h) { if (l.min[t] <= this.startPan[t]) return r.moveTo(c, !0), !0; this.D(t, p) } else if (p < l.max[t] && e) { if (this.startPan[t] <= l.max[t]) return r.moveTo(c, !0), !0; this.D(t, p) } else if (0 !== s) { if (s > 0) return r.moveTo(Math.max(c, i), !0), !0; if (s < 0) return r.moveTo(Math.min(c, i), !0), !0 } else this.D(t, p) } else "y" === t && (r.isShifted() || l.min.y === l.max.y) || this.D(t, p) } I(t) { return (t - this.pswp.currSlide.bounds.center.y) / (this.pswp.viewportSize.y / 3) } D(t, i, s) { const { pan: h, bounds: e } = this.pswp.currSlide; if (e.correctPan(t, i) !== i || s) { const e = Math.round(i - h[t]); h[t] += e * (s || .35) } else h[t] = i } } function y(t, i, s) { return t.x = (i.x + s.x) / 2, t.y = (i.y + s.y) / 2, t } class v { constructor(t) { this.gestures = t, this.pswp = this.gestures.pswp, this.Z = {}, this.O = {}, this.R = {} } start() { this.L = this.pswp.currSlide.currZoomLevel, i(this.Z, this.pswp.currSlide.pan), this.pswp.animations.stopAllPan(), this.F = !1 } change() { const { p1: t, startP1: i, p2: s, startP2: e, pswp: n } = this.gestures, { currSlide: o } = n, r = o.zoomLevels.min, a = o.zoomLevels.max; if (!o.isZoomable() || n.mainScroll.isShifted()) return; y(this.O, i, e), y(this.R, t, s); let c = 1 / h(i, e) * h(t, s) * this.L; if (c > o.zoomLevels.initial + o.zoomLevels.initial / 15 && (this.F = !0), c < r) if (n.options.pinchToClose && !this.F && this.L <= o.zoomLevels.initial) { const t = 1 - (r - c) / (r / 1.2); n.dispatch("pinchClose", { bgOpacity: t }).defaultPrevented || n.applyBgOpacity(t) } else c = r - .25 * (r - c); else c > a && (c = a + .15 * (c - a)); o.pan.x = this.B("x", c), o.pan.y = this.B("y", c), o.setZoomLevel(c), o.applyCurrentZoomPan() } end() { const { pswp: t } = this, { currSlide: i } = t; i.currZoomLevel < i.zoomLevels.initial && !this.F && t.options.pinchToClose ? t.close() : this.correctZoomPan() } B(t, i) { const s = i / this.L; return this.R[t] - (this.O[t] - this.Z[t]) * s } correctZoomPan() { const { pswp: t } = this, { currSlide: s } = t; if (!s.isZoomable()) return; const h = s.currZoomLevel; let o, r = !0; h < s.zoomLevels.initial ? o = s.zoomLevels.initial : h > s.zoomLevels.max ? o = s.zoomLevels.max : (r = !1, o = h); const a = t.bgOpacity, c = t.bgOpacity < 1, l = i({}, s.pan); let p = i({}, l); r && (p = { x: this.B("x", o), y: this.B("y", o) }), s.setZoomLevel(o), p = { x: s.bounds.correctPan("x", p.x), y: s.bounds.correctPan("y", p.y) }, s.setZoomLevel(h); let u = !0; e(p, l) && (u = !1), (u || r || c) && (t.animations.stopAllPan(), t.animations.startSpring({ isPan: !0, start: 0, end: 1e3, velocity: 0, dampingRatio: 1, naturalFrequency: 30, onUpdate: i => { if (i /= 1e3, u || r) { if (u && (s.pan.x = l.x + (p.x - l.x) * i, s.pan.y = l.y + (p.y - l.y) * i), r) { const t = h + (o - h) * i; s.setZoomLevel(t) } s.applyCurrentZoomPan() } c && t.bgOpacity < 1 && t.applyBgOpacity(n(a + (1 - a) * i, 0, 1)) } })) } } function x(t) { return !!t.target.closest(".pswp__container") } class b { constructor(t) { this.gestures = t } click(t, i) { const s = i.target.classList, h = s.contains("pswp__img"), e = s.contains("pswp__item") || s.contains("pswp__zoom-wrap"); h ? this.U("imageClick", t, i) : e && this.U("bgClick", t, i) } tap(t, i) { x(i) && this.U("tap", t, i) } doubleTap(t, i) { x(i) && this.U("doubleTap", t, i) } U(t, i, s) { const { pswp: h } = this.gestures, { currSlide: e } = h, n = h.options[t + "Action"]; if ("function" != typeof n) switch (n) { case "close": case "next": h[n](); break; case "zoom": e.toggleZoom(i); break; case "zoom-or-close": e.isZoomable() && e.zoomLevels.secondary !== e.zoomLevels.initial ? e.toggleZoom(i) : h.options.clickToCloseNonZoomable && h.close(); break; case "toggle-controls": this.gestures.pswp.template.classList.toggle("pswp--ui-visible") } else n.call(h, i, s) } } class M { constructor(t) { this.pswp = t, this.p1 = {}, this.p2 = {}, this.prevP1 = {}, this.prevP2 = {}, this.startP1 = {}, this.startP2 = {}, this.velocity = {}, this.V = {}, this.G = {}, this.N = 0, this.q = [], this.H = "ontouchstart" in window, this.j = !!window.PointerEvent, this.supportsTouch = this.H || this.j && navigator.maxTouchPoints > 1, this.supportsTouch || (t.options.allowPanToNext = !1), this.drag = new _(this), this.zoomLevels = new v(this), this.tapHandler = new b(this), t.on("bindEvents", (() => { t.events.add(t.scrollWrap, "click", (t => this.K(t))), this.j ? this.W("pointer", "down", "up", "cancel") : this.H ? (this.W("touch", "start", "end", "cancel"), t.scrollWrap.ontouchmove = () => { }, t.scrollWrap.ontouchend = () => { }) : this.W("mouse", "down", "up") })) } W(t, i, s, h) { const { pswp: e } = this, { events: n } = e, o = h ? t + h : ""; n.add(e.scrollWrap, t + i, this.onPointerDown.bind(this)), n.add(window, t + "move", this.onPointerMove.bind(this)), n.add(window, t + s, this.onPointerUp.bind(this)), o && n.add(e.scrollWrap, o, this.onPointerUp.bind(this)) } onPointerDown(t) { let s; if ("mousedown" !== t.type && "mouse" !== t.pointerType || (s = !0), s && t.button > 0) return; const { pswp: h } = this; h.opener.isOpen ? h.dispatch("pointerDown", { originalEvent: t }).defaultPrevented || (s && (h.mouseDetected(), this.X(t)), h.animations.stopAll(), this.Y(t), this.pointerDown = !0, 1 === this.N && (this.dragAxis = null, i(this.startP1, this.p1)), this.N > 1 ? (this.J(), this.isMultitouch = !0) : this.isMultitouch = !1) : t.preventDefault() } onPointerMove(t) { t.preventDefault(), this.N && (this.Y(t), this.pswp.dispatch("pointerMove", { originalEvent: t }).defaultPrevented || (1 !== this.N || this.isDragging ? this.N > 1 && !this.isZooming && (this.$(), this.isZooming = !0, this.tt(), this.zoomLevels.start(), this.it(), this.st()) : (this.dragAxis || this.ht(), this.dragAxis && !this.isDragging && (this.isZooming && (this.isZooming = !1, this.zoomLevels.end()), this.isDragging = !0, this.J(), this.tt(), this.et = Date.now(), this.nt = !1, i(this.G, this.p1), this.velocity.x = 0, this.velocity.y = 0, this.drag.start(), this.it(), this.st())))) } $() { this.isDragging && (this.isDragging = !1, this.nt || this.ot(!0), this.drag.end(), this.dragAxis = null) } onPointerUp(t) { this.N && (this.Y(t, !0), this.pswp.dispatch("pointerUp", { originalEvent: t }).defaultPrevented || (0 === this.N && (this.pointerDown = !1, this.it(), this.isDragging ? this.$() : this.isZooming || this.isMultitouch || this.rt(t)), this.N < 2 && this.isZooming && (this.isZooming = !1, this.zoomLevels.end(), 1 === this.N && (this.dragAxis = null, this.tt())))) } st() { (this.isDragging || this.isZooming) && (this.ot(), this.isDragging ? e(this.p1, this.prevP1) || this.drag.change() : e(this.p1, this.prevP1) || e(this.p2, this.prevP2) || this.zoomLevels.change(), this.at(), this.raf = requestAnimationFrame(this.st.bind(this))) } ot(t) { const s = Date.now(), h = s - this.et; h < 50 && !t || (this.velocity.x = this.ct("x", h), this.velocity.y = this.ct("y", h), this.et = s, i(this.G, this.p1), this.nt = !0) } rt(t) { const { mainScroll: s } = this.pswp; if (s.isShifted()) return void s.moveIndexBy(0, !0); if (t.type.indexOf("cancel") > 0) return; if ("mouseup" === t.type || "mouse" === t.pointerType) return void this.tapHandler.click(this.startP1, t); const e = this.pswp.options.doubleTapAction ? 300 : 0; this.lt ? (this.J(), h(this.V, this.startP1) < 25 && this.tapHandler.doubleTap(this.startP1, t)) : (i(this.V, this.startP1), this.lt = setTimeout((() => { this.tapHandler.tap(this.startP1, t), this.J() }), e)) } J() { this.lt && (clearTimeout(this.lt), this.lt = null) } ct(t, i) { const s = this.p1[t] - this.G[t]; return Math.abs(s) > 1 && i > 5 ? s / i : 0 } it() { this.raf && (cancelAnimationFrame(this.raf), this.raf = null) } X(t) { return t.preventDefault(), !0 } Y(t, s) { if (this.j) { const h = this.q.findIndex((i => i.id === t.pointerId)); s && h > -1 ? this.q.splice(h, 1) : s || -1 !== h ? h > -1 && this.ut(t, this.q[h]) : this.q.push(this.ut(t, {})), this.N = this.q.length, this.N > 0 && i(this.p1, this.q[0]), this.N > 1 && i(this.p2, this.q[1]) } else this.N = 0, t.type.indexOf("touch") > -1 ? t.touches && t.touches.length > 0 && (this.ut(t.touches[0], this.p1), this.N++, t.touches.length > 1 && (this.ut(t.touches[1], this.p2), this.N++)) : (this.ut(t, this.p1), s ? this.N = 0 : this.N++) } at() { i(this.prevP1, this.p1), i(this.prevP2, this.p2) } tt() { i(this.startP1, this.p1), i(this.startP2, this.p2), this.at() } ht() { if (this.pswp.mainScroll.isShifted()) this.dragAxis = "x"; else { const t = Math.abs(this.p1.x - this.startP1.x) - Math.abs(this.p1.y - this.startP1.y); if (0 !== t) { const i = t > 0 ? "x" : "y"; Math.abs(this.p1[i] - this.startP1[i]) >= 10 && (this.dragAxis = i) } } } ut(t, i) { return i.x = t.pageX - this.pswp.offset.x, i.y = t.pageY - this.pswp.offset.y, void 0 !== t.pointerId ? i.id = t.pointerId : void 0 !== t.identifier && (i.id = t.identifier), i } K(t) { this.pswp.mainScroll.isShifted() && (t.preventDefault(), t.stopPropagation()) } } class P { constructor(t) { this.pswp = t, this.x = 0, this.slideWidth = 0, this.resetPosition() } resize(t) { const { pswp: i } = this; this.slideWidth = Math.round(i.viewportSize.x + i.viewportSize.x * i.options.spacing), this.moveTo(this.getCurrSlideX()), this.itemHolders.forEach(((i, s) => { r(i.el, (s + this.dt) * this.slideWidth), t && i.slide && i.slide.resize() })) } resetPosition() { this.ft = 0, this.wt = 0, this.dt = -1 } appendHolders() { this.itemHolders = []; for (let i = 0; i < 3; i++) { const s = t("pswp__item", !1, this.pswp.container); s.style.display = 1 === i ? "block" : "none", this.itemHolders.push({ el: s }) } } canBeSwiped() { return this.pswp.getNumItems() > 1 } moveIndexBy(t, i, s) { const { pswp: h } = this; let e = h.potentialIndex + t; h.options.loop ? e = h.getLoopedIndex(e) : (e < 0 ? e = 0 : e >= h.getNumItems() && (e = h.getNumItems() - 1), t = e - h.potentialIndex), h.potentialIndex = e, this.ft -= t, h.animations.stopMainScroll(); const n = this.getCurrSlideX(); if (i ? (h.animations.startSpring({ isMainScroll: !0, start: this.x, end: n, velocity: s || 0, naturalFrequency: 30, dampingRatio: 1, onUpdate: t => { this.x = t, r(this.pswp.container, t) }, onComplete: () => { this.updateCurrItem(), h.appendHeavy() } }), Math.abs(h.potentialIndex - h.currIndex) > 1 && this.updateCurrItem()) : (this.moveTo(n), this.updateCurrItem()), t) return !0 } getCurrSlideX() { return this.slideWidth * this.ft } isShifted() { return this.x !== this.getCurrSlideX() } updateCurrItem() { const { pswp: t } = this, i = this.wt - this.ft; if (!i) return; this.wt = this.ft, t.currIndex = t.potentialIndex, t.currItemData = t.getItemData(t.currIndex); let s, h = Math.abs(i); h >= 3 && (this.dt += i + (i > 0 ? -3 : 3), h = 3); for (let e = 0; e < h; e++)i > 0 ? (s = this.itemHolders.shift(), this.itemHolders[2] = s, this.dt++, r(s.el, (this.dt + 2) * this.slideWidth), t.setContent(s, t.currIndex - h + e + 2)) : (s = this.itemHolders.pop(), this.itemHolders.unshift(s), this.dt--, r(s.el, this.dt * this.slideWidth), t.setContent(s, t.currIndex + h - e - 2)); Math.abs(this.dt) > 50 && !this.isShifted() && (this.resetPosition(), this.resize()), t.animations.stopAllPan(), this.itemHolders.forEach(((t, i) => { t.slide && t.slide.setIsActive(1 === i) })), t.currSlide = this.itemHolders[1].slide, t.lazyLoader.update(i), t.currSlide.applyCurrentZoomPan(), t.dispatch("change") } moveTo(t, i) { let s, h; !this.pswp.options.loop && i && (s = (this.slideWidth * this.ft - t) / this.slideWidth, s += this.pswp.currIndex, h = Math.round(t - this.x), (s < 0 && h > 0 || s >= this.pswp.getNumItems() - 1 && h < 0) && (t = this.x + .35 * h)), this.x = t, r(this.pswp.container, t) } } class S { constructor(t) { this.pswp = t, t.on("bindEvents", (() => { t.options.initialPointerPos || this.gt(), t.events.add(document, "focusin", this._t.bind(this)), t.events.add(document, "keydown", this.yt.bind(this)) })); const i = document.activeElement; t.on("destroy", (() => { t.options.returnFocus && i && this.vt && i.focus() })) } gt() { this.vt || (this.pswp.template.focus(), this.vt = !0) } yt(t) { const { pswp: i } = this; if (i.dispatch("keydown", { originalEvent: t }).defaultPrevented) return; if (function (t) { if (2 === t.which || t.ctrlKey || t.metaKey || t.altKey || t.shiftKey) return !0 }(t)) return; let s, h, e; switch (t.keyCode) { case 27: i.options.escKey && (s = "close"); break; case 90: s = "toggleZoom"; break; case 37: h = "x"; break; case 38: h = "y"; break; case 39: h = "x", e = !0; break; case 40: e = !0, h = "y"; break; case 9: this.gt() }if (h) { t.preventDefault(); const { currSlide: n } = i; i.options.arrowKeys && "x" === h && i.getNumItems() > 1 ? s = e ? "next" : "prev" : n && n.currZoomLevel > n.zoomLevels.fit && (n.pan[h] += e ? -80 : 80, n.panTo(n.pan.x, n.pan.y)) } s && (t.preventDefault(), i[s]()) } _t(t) { const { template: i } = this.pswp; document === t.target || i === t.target || i.contains(t.target) || i.focus() } } class T { constructor(t) { this.props = t; const { target: i, onComplete: s, transform: h } = t; let { duration: e, easing: n } = t; const o = h ? "transform" : "opacity", r = t[o]; this.xt = i, this.bt = s, e = e || 333, n = n || "cubic-bezier(.4,0,.22,1)", this.Mt = this.Mt.bind(this), this.Pt = setTimeout((() => { a(i, o, e, n), this.Pt = setTimeout((() => { i.addEventListener("transitionend", this.Mt, !1), i.addEventListener("transitioncancel", this.Mt, !1), i.style[o] = r }), 30) }), 0) } Mt(t) { t.target === this.xt && this.St() } St() { this.Tt || (this.Tt = !0, this.onFinish(), this.bt && this.bt()) } destroy() { this.Pt && clearTimeout(this.Pt), a(this.xt), this.xt.removeEventListener("transitionend", this.Mt, !1), this.xt.removeEventListener("transitioncancel", this.Mt, !1), this.Tt || this.St() } } class z { constructor(t, i, s) { this.velocity = 1e3 * t, this.zt = i || .75, this.Ct = s || 12, this.zt < 1 && (this.Dt = this.Ct * Math.sqrt(1 - this.zt * this.zt)) } easeFrame(t, i) { let s, h = 0; i /= 1e3; const e = Math.E ** (-this.zt * this.Ct * i); if (1 === this.zt) s = this.velocity + this.Ct * t, h = (t + s * i) * e, this.velocity = h * -this.Ct + s * e; else if (this.zt < 1) { s = 1 / this.Dt * (this.zt * this.Ct * t + this.velocity); const n = Math.cos(this.Dt * i), o = Math.sin(this.Dt * i); h = e * (t * n + s * o), this.velocity = h * -this.Ct * this.zt + e * (-this.Dt * t * o + this.Dt * s * n) } return h } } class C { constructor(t) { this.props = t; const { start: i, end: s, velocity: h, onUpdate: e, onComplete: n, onFinish: o, dampingRatio: r, naturalFrequency: a } = t, c = new z(h, r, a); let l = Date.now(), p = i - s; this.It = o; const u = () => { this.At && (p = c.easeFrame(p, Date.now() - l), Math.abs(p) < 1 && Math.abs(c.velocity) < 50 ? (e(s), n && n(), this.onFinish()) : (l = Date.now(), e(p + s), this.At = requestAnimationFrame(u))) }; this.At = requestAnimationFrame(u) } destroy() { this.At >= 0 && cancelAnimationFrame(this.At), this.At = null } } class D { constructor() { this.activeAnimations = [] } startSpring(t) { this.kt(t, !0) } startTransition(t) { this.kt(t) } kt(t, i) { let s; return s = i ? new C(t) : new T(t), this.activeAnimations.push(s), s.onFinish = () => this.stop(s), s } stop(t) { t.destroy(); const i = this.activeAnimations.indexOf(t); i > -1 && this.activeAnimations.splice(i, 1) } stopAll() { this.activeAnimations.forEach((t => { t.destroy() })), this.activeAnimations = [] } stopAllPan() { this.activeAnimations = this.activeAnimations.filter((t => !t.props.isPan || (t.destroy(), !1))) } stopMainScroll() { this.activeAnimations = this.activeAnimations.filter((t => !t.props.isMainScroll || (t.destroy(), !1))) } isPanRunning() { return this.activeAnimations.some((t => t.props.isPan)) } } class I { constructor(t) { this.pswp = t, t.events.add(t.template, "wheel", this.Et.bind(this)) } Et(t) { t.preventDefault(); const { currSlide: i } = this.pswp; let { deltaX: s, deltaY: h } = t; if (i) if (this.pswp.dispatch("wheel"), 1 === t.deltaMode && (s *= 18, h *= 18), t.ctrlKey || this.pswp.options.wheelToZoom) { if (i.isZoomable()) { const s = i.currZoomLevel - .04 * i.zoomLevels.fit * h; i.zoomTo(s, { x: t.clientX, y: t.clientY }) } } else i.isPannable() && i.panTo(i.pan.x - s, i.pan.y - h) } } class A { constructor(i, s) { const h = s.name || s.class; if (!1 === i.options[h]) return; "string" == typeof i.options[h + "SVG"] && (s.html = i.options[h + "SVG"]), i.dispatch("uiElementCreate", { data: s }); let e, n = "pswp__"; s.isButton && (n += "button pswp__button--"), n += s.class || s.name, s.isButton ? (e = t(n, "button"), e.type = "button", e.innerHTML = function (t) { if ("string" == typeof t) return t; if (!t || !t.isCustomSVG) return ""; const i = t; let s = '<svg aria-hidden="true" class="pswp__icn" viewBox="0 0 %d %d" width="%d" height="%d">'; return s = s.split("%d").join(i.size || 32), i.outlineID && (s += '<use class="pswp__icn-shadow" xlink:href="#' + i.outlineID + '"/>'), s += i.inner, s += "</svg>", s }(s.html), s.title && (e.title = s.title)) : e = t(n), s.onInit && s.onInit(e, i), s.onClick && (e.onclick = t => { "string" == typeof s.onClick ? i[s.onClick]() : s.onClick(t, e, i) }); const o = s.appendTo || "bar"; let r; "bar" === o ? (i.topBar || (i.topBar = t("pswp__top-bar pswp__hide-on-close", !1, i.scrollWrap)), r = i.topBar) : (e.classList.add("pswp__hide-on-close"), r = "wrapper" === o ? i.scrollWrap : i.template), r.appendChild(e) } } const k = { name: "close", title: "Close", order: 20, isButton: !0, html: { isCustomSVG: !0, inner: '<path d="M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z" id="pswp__icn-close"/>', outlineID: "pswp__icn-close" }, onClick: "close" }, E = { name: "preloader", appendTo: "wrapper", onInit: (t, i) => { let s, h, e; const n = () => { s && (t.style.left = Math.round((i.viewportSize.x - 24) / 2) + "px", t.style.top = Math.round((i.viewportSize.y - 24) / 2) + "px") }, o = (i, s) => { t.classList[s ? "add" : "remove"]("pswp__preloader--" + i) }, r = t => { s !== t && (s = t, clearTimeout(e), o("hiding", !t), t ? (n(), o("active", !0)) : e = setTimeout((() => { o("active", !1) }), 350)) }; i.on("change", (() => { i.currSlide.isLoading ? (clearTimeout(h), h = setTimeout((() => { r(i.currSlide.isLoading) }), 1100)) : r(!1) })), i.on("loadComplete", (t => { i.currSlide === t.slide && r(!1) })), i.on("resize", n) } }, Z = { name: "counter", order: 5, onInit: (t, i) => { i.on("change", (() => { t.innerHTML = i.currIndex + 1 + i.options.indexIndicatorSep + i.getNumItems() })) } }; function O(t, i) { t.classList[i ? "add" : "remove"]("pswp--zoomed-in") } class R { constructor(t) { this.pswp = t } init() { const { pswp: t } = this; this.isRegistered = !1, this.uiElementsData = [k, E, Z], t.dispatch("uiRegister"), this.uiElementsData.sort(((t, i) => (t.order || 0) - (i.order || 0))), this.items = [], this.isRegistered = !0, this.uiElementsData.forEach((t => { this.registerElement(t) })), 1 === t.getNumItems() && t.template.classList.add("pswp--one-slide"), t.on("zoomPanUpdate", (() => this.Zt())) } registerElement(t) { this.isRegistered ? this.items.push(new A(this.pswp, t)) : this.uiElementsData.push(t) } Zt() { const { template: t, currSlide: i, options: s } = this.pswp; let { currZoomLevel: h } = i; if (this.pswp.opener.isClosing) return; if (this.pswp.opener.isOpen || (h = i.zoomLevels.initial), h === this.Ot) return; this.Ot = h; const e = i.zoomLevels.initial - i.zoomLevels.secondary; if (Math.abs(e) < .01) return O(t, !1), void t.classList.remove("pswp--zoom-allowed"); t.classList.add("pswp--zoom-allowed"); const n = e < 0; h === i.zoomLevels.secondary ? O(t, n) : h > i.zoomLevels.secondary ? O(t, !0) : O(t, !1), "zoom" !== s.imageClickAction && "zoom-or-close" !== s.imageClickAction || t.classList.add("pswp--click-to-zoom") } } class L { constructor(t) { this.pswp = t, this.clearRecent() } update(t) { const { pswp: i } = this; if (i.dispatch("lazyLoad").defaultPrevented) return; const { preload: s } = i.options, h = void 0 === t || t >= 0; let e; for (e = 0; e <= s[1]; e++)this.Rt(i.currIndex + (h ? e : -e)); for (e = 1; e <= s[0]; e++)this.Rt(i.currIndex + (h ? -e : e)) } clearRecent() { this.Lt = [] } addRecent(t) { if (!(this.Lt.indexOf(t) > -1)) return this.Lt.length > 14 && this.Lt.pop(), this.Lt.unshift(t), !0 } Rt(t) { t = this.pswp.getLoopedIndex(t), this.addRecent(t) && function (t, i) { const s = i.getItemData(t); if (!i.dispatch("lazyLoadSlide", { index: t, itemData: s }).defaultPrevented && s.src && s.w && s.h) { const { options: h } = i, e = f(h, i.viewportSize || m(h)), n = new d(h, s, t); n.update(s.w, s.h, e); const o = document.createElement("img"); o.decoding = "async", o.sizes = Math.ceil(s.w * n.initial) + "px", o.src = s.src, s.srcset && (o.srcset = s.srcset) } }(t, this.pswp) } } class F { constructor(t, i) { this.type = t, i && Object.assign(this, i) } preventDefault() { this.defaultPrevented = !0 } } class B { constructor(t) { this.pswp = t, this.isClosed = !0, this.Ft = this.Ft.bind(this), t.on("firstZoomPan", this.Ft) } open() { this.Ft(), this.kt() } close() { return !(this.isClosed || this.isClosing || this.isOpening) && (this.isOpen = !1, this.isOpening = !1, this.isClosing = !0, this.Bt = this.pswp.options.hideAnimationDuration, this.Ut(), setTimeout((() => { this.kt() }), this.Vt ? 30 : 0), !0) } Ft() { this.pswp.off("firstZoomPan", this.Ft), this.isOpening || (this.isOpening = !0, this.isClosing = !1, this.Bt = this.pswp.options.showAnimationDuration, this.Ut()) } Ut() { const { pswp: t } = this, i = this.pswp.currSlide, { options: s } = t; if ("fade" === s.showHideAnimationType ? (s.showHideOpacity = !0, this.Gt = !1) : "none" === s.showHideAnimationType ? (s.showHideOpacity = !1, this.Bt = 0, this.Gt = !1) : this.isOpening && t.Nt ? this.Gt = t.Nt : this.Gt = this.pswp.getThumbBounds(), this.qt = i.getPlaceholder(), t.animations.stopAll(), this.Ht = this.Bt > 50, this.jt = Boolean(this.Gt) && i.isZoomable() && (!this.isClosing || !t.mainScroll.isShifted()), this.jt ? this.Kt = s.showHideOpacity : (this.Kt = !0, this.isOpening && (i.zoomAndPanToInitial(), i.applyCurrentZoomPan())), this.Wt = !this.Kt, this.Xt = this.Kt ? t.template : t.bg, !this.Ht) return this.Bt = 0, this.jt = !1, this.Wt = !1, this.Kt = !0, void (this.isOpening && (t.template.style.opacity = .003, t.applyBgOpacity(1))); this.jt && this.Gt.innerRect ? (this.Vt = !0, this.Yt = this.pswp.container, this.Jt = this.pswp.currSlide.holderElement, t.container.style.overflow = "hidden", t.container.style.width = t.viewportSize.x + "px") : this.Vt = !1, this.isOpening ? (this.Wt && (t.bg.style.opacity = .003, t.template.style.opacity = 1), this.Kt && (t.template.style.opacity = .003, t.applyBgOpacity(1)), this.jt && (this.Qt(), this.qt && (this.qt.willChange = "transform", this.qt.style.opacity = .003))) : this.isClosing && (t.mainScroll.itemHolders[0].el.style.display = "none", t.mainScroll.itemHolders[2].el.style.display = "none", this.Vt && 0 !== t.mainScroll.x && (t.mainScroll.resetPosition(), t.mainScroll.resize())) } kt() { this.isOpening && this.Ht && this.qt && "IMG" === this.qt.tagName ? new Promise((t => { let i = !1, s = !0; c(this.qt).finally((() => { i = !0, s || t() })), setTimeout((() => { s = !1, i && t() }), 50), setTimeout(t, 250) })).finally((() => this.$t())) : this.$t() } $t() { this.pswp.template.style.setProperty("--pswp-transition-duration", this.Bt + "ms"), this.pswp.dispatch("initialZoom" + (this.isOpening ? "In" : "Out")), this.pswp.template.classList[this.isOpening ? "add" : "remove"]("pswp--ui-visible"), this.isOpening ? (this.qt && (this.qt.style.opacity = 1), this.ti()) : this.isClosing && this.ii(), this.Ht || this.si() } si() { const { pswp: t } = this; this.isOpen = this.isOpening, this.isClosed = this.isClosing, this.isOpening = !1, this.isClosing = !1, t.dispatch("initialZoom" + (this.isOpen ? "InEnd" : "OutEnd")), this.isClosed ? t.destroy() : this.isOpen && (this.jt && (t.container.style.overflow = "visible", t.container.style.width = "100%"), t.currSlide.applyCurrentZoomPan()) } ti() { const { pswp: t } = this; this.jt && (this.Vt && (this.hi(this.Yt, "transform", "translate3d(0,0,0)"), this.hi(this.Jt, "transform", "none")), t.currSlide.zoomAndPanToInitial(), this.hi(t.currSlide.container, "transform", t.currSlide.getCurrentTransform())), this.Wt && this.hi(t.bg, "opacity", t.options.bgOpacity), this.Kt && this.hi(t.template, "opacity", 1) } ii() { const { pswp: t } = this; this.jt && this.Qt(!0), this.Wt && t.bgOpacity > .01 && this.hi(t.bg, "opacity", 0), this.Kt && this.hi(t.template, "opacity", 0) } Qt(t) { const { pswp: s } = this, { innerRect: h } = this.Gt, { currSlide: e, viewportSize: n } = s; if (this.Vt) { const i = -n.x + (this.Gt.x - h.x) + h.w, s = -n.y + (this.Gt.y - h.y) + h.h, e = n.x - h.w, a = n.y - h.h; t ? (this.hi(this.Yt, "transform", o(i, s)), this.hi(this.Jt, "transform", o(e, a))) : (r(this.Yt, i, s), r(this.Jt, e, a)) } i(e.pan, h || this.Gt), e.currZoomLevel = this.Gt.w / e.width, t ? this.hi(e.container, "transform", e.getCurrentTransform()) : e.applyCurrentZoomPan() } hi(t, i, s) { if (!this.Bt) return void (t.style[i] = s); const { animations: h } = this.pswp, e = { duration: this.Bt, easing: this.pswp.options.easing, onComplete: () => { h.activeAnimations.length || this.si() }, target: t }; e[i] = s, h.startTransition(e) } } const U = { allowPanToNext: !0, spacing: .1, loop: !0, pinchToClose: !0, closeOnVerticalDrag: !0, hideAnimationDuration: 333, showAnimationDuration: 333, zoomAnimationDuration: 333, escKey: !0, arrowKeys: !0, returnFocus: !0, clickToCloseNonZoomable: !0, imageClickAction: "zoom-or-close", bgClickAction: "close", tapAction: "toggle-controls", doubleTapAction: "zoom", indexIndicatorSep: " / ", panPaddingRatio: .15, bgOpacity: .8, index: 0, errorMsg: '<div class="pswp__error-msg"><a href="" target="_blank">The image</a> could not be loaded.</div>', preload: [1, 2], easing: "cubic-bezier(.4,0,.22,1)", paddingTop: 0, paddingBottom: 0, paddingLeft: 0, paddingRight: 0 }; export default class extends class extends class { constructor() { this.ei = {} } on(t, i) { this.ei[t] || (this.ei[t] = []), this.ei[t].push(i), this.pswp && this.pswp.on(t, i) } off(t, i) { this.ei[t] && (this.ei[t] = this.ei[t].filter((t => i !== t))), this.pswp && this.pswp.off(t, i) } dispatch(t, i) { if (this.pswp) return this.pswp.dispatch(t, i); const s = new F(t, i); return this.ei ? (this.ei[t] && this.ei[t].forEach((t => { t.call(this, s) })), s) : s } }{ getNumItems() { let t; const { dataSource: i } = this.options; i ? i.length ? t = i.length : i.gallery && (i.items || (i.items = this.ni(i.gallery)), i.items && (t = i.items.length)) : t = 0; return this.dispatch("numItems", { dataSource: i, numItems: t }).numItems } getItemData(t) { const { dataSource: i } = this.options; let s; Array.isArray(i) ? s = i[t] : i && i.gallery && (i.items || (i.items = this.ni(i.gallery)), s = i.items[t]); let h = s; h instanceof Element && (h = this.oi(h)); return this.dispatch("itemData", { itemData: h || {}, index: t }).itemData } ni(t) { return this.options.childSelector ? t.querySelectorAll(this.options.childSelector) || [] : [t] } oi(t) { const i = { element: t }, s = "A" === t.tagName ? t : t.querySelector("a"); if (!s) return i; i.src = s.dataset.pswpSrc || s.href, i.srcset = s.dataset.pswpSrcset, i.w = parseInt(s.dataset.pswpWidth, 10), i.h = parseInt(s.dataset.pswpHeight, 10); const h = t.querySelector("img"); return h && (i.msrc = h.currentSrc || h.src, i.alt = h.getAttribute("alt")), s.dataset.cropped && (i.thumbCropped = !0), i } }{ constructor(t, i) { super(), this.items = t, this.ri(i), this.offset = {}, this.ai = {}, this.viewportSize = {}, this.bgOpacity = 1, this.events = new p, this.animations = new D, this.mainScroll = new P(this), this.gestures = new M(this), this.opener = new B(this), this.keyboard = new S(this), this.lazyLoader = new L(this) } init() { if (this.isOpen || this.isDestroying) return; this.isOpen = !0, this.getNumItems() < 3 && (this.options.loop = !1), this.ci(), this.li(); let t = "pswp--open"; return this.gestures.supportsTouch && (t += " pswp--touch"), this.options.allowMouseDrag || (t += " pswp--no-mouse-drag"), this.options.mainClass && (t += " " + this.options.mainClass), this.template.className += " " + t, this.currIndex = this.options.index || 0, this.potentialIndex = this.currIndex, this.dispatch("firstUpdate"), this.scrollWheel = new I(this), (Number.isNaN(this.currIndex) || this.currIndex < 0 || this.currIndex >= this.getNumItems()) && (this.currIndex = 0), this.currItemData = this.getItemData(this.currIndex), this.gestures.supportsTouch || this.mouseDetected(), this.updateSize(), this.offset.y = window.pageYOffset, this.dispatch("gettingData", this.currIndex, this.currItemData, !0), this.Nt = this.getThumbBounds(), this.dispatch("initialLayout"), this.on("initialZoomInEnd", (() => { this.setContent(this.mainScroll.itemHolders[0], this.currIndex - 1), this.setContent(this.mainScroll.itemHolders[2], this.currIndex + 1), this.mainScroll.itemHolders[0].el.style.display = "block", this.mainScroll.itemHolders[2].el.style.display = "block", this.appendHeavy(), this.lazyLoader.update(), this.events.add(window, "resize", this.pi.bind(this)), this.events.add(window, "scroll", this.di.bind(this)), this.dispatch("bindEvents") })), this.setContent(this.mainScroll.itemHolders[1], this.currIndex), this.dispatch("change"), this.opener.open(), this.dispatch("afterInit"), !0 } getLoopedIndex(t) { const i = this.getNumItems(); return this.options.loop && (t > i - 1 && (t -= i), t < 0 && (t += i)), t = n(t, 0, i - 1) } getIndexDiff(t) { if (this.options.loop) { const i = this.getNumItems() - 1; if (0 === this.currIndex && t === i) return -1; if (this.currIndex === i && 0 === t) return 1 } return t - this.currIndex } appendHeavy() { this.mainScroll.itemHolders.forEach((t => { t.slide && t.slide.appendHeavy() })) } goTo(t) { t = this.getLoopedIndex(t); this.mainScroll.moveIndexBy(t - this.potentialIndex) && this.dispatch("afterGoto") } next() { this.goTo(this.potentialIndex + 1) } prev() { this.goTo(this.potentialIndex - 1) } zoomTo(...t) { this.currSlide.zoomTo(...t) } toggleZoom() { this.currSlide.toggleZoom() } close() { this.opener.isOpen && !this.isDestroying && (this.isDestroying = !0, this.dispatch("close"), this.events.removeAll(), this.opener.close()) } destroy() { this.isDestroying ? (this.dispatch("destroy"), this.listeners = null, this.scrollWrap.ontouchmove = null, this.scrollWrap.ontouchend = null, this.template.remove(), this.events.removeAll()) : this.close() } setContent(t, i) { if (t.slide && t.slide.destroy(), this.options.loop) i = this.getLoopedIndex(i); else if (i < 0 || i >= this.getNumItems()) return void (t.el.innerHTML = ""); const s = this.getItemData(i); t.slide = new g(s, i, this), i === this.currIndex && (this.currSlide = t.slide), t.slide.append(t.el) } getViewportCenterPoint() { return { x: this.viewportSize.x / 2, y: this.viewportSize.y / 2 } } updateSize(t) { if (this.isDestroying) return; const s = m(this.options, this); !t && e(s, this.ai) || (i(this.ai, s), this.dispatch("beforeResize"), i(this.viewportSize, this.ai), this.di(), this.dispatch("viewportSize"), this.mainScroll.resize(this.opener.isOpen), !this.hasMouse && window.matchMedia("(any-hover: hover)").matches && this.mouseDetected(), this.dispatch("resize")) } applyBgOpacity(t) { this.bgOpacity = Math.max(t, 0), this.bg.style.opacity = this.bgOpacity * this.options.bgOpacity } mouseDetected() { this.hasMouse || (this.hasMouse = !0, this.template.classList.add("pswp--has_mouse")) } pi() { this.updateSize(), /iPhone|iPad|iPod/i.test(window.navigator.userAgent) && setTimeout((() => { this.updateSize() }), 500) } di() { this.setScrollOffset(0, window.pageYOffset) } setScrollOffset(t, i) { this.offset.x = t, this.offset.y = i, this.dispatch("updateScrollOffset") } li() { this.template = t("pswp"), this.template.setAttribute("tabindex", -1), this.template.setAttribute("role", "dialog"), this.bg = t("pswp__bg", !1, this.template), this.scrollWrap = t("pswp__scroll-wrap", !1, this.template), this.container = t("pswp__container", !1, this.scrollWrap), this.mainScroll.appendHolders(), this.ui = new R(this), this.ui.init(), (this.options.appendToEl || document.body).appendChild(this.template) } getThumbBounds() { return function (t, i, s) { const h = s.dispatch("thumbBounds", { index: t, itemData: i, instance: s }); if (h.thumbBounds) return h.thumbBounds; const { element: e } = i; if (!e || !1 === s.options.thumbSelector) return; const n = s.options.thumbSelector || "img", o = e.matches(n) ? e : e.querySelector(n); if (!o) return; const r = o.getBoundingClientRect(); if (!i.thumbCropped) return { x: r.left, y: r.top, w: r.width }; const a = i.w, c = i.h; if (!a || !c) return; const l = r.width / a, p = r.height / c, u = l > p ? l : p, d = (r.width - a * u) / 2, m = (r.height - c * u) / 2, f = { x: r.left + d, y: r.top + m, w: a * u }; return f.innerRect = { w: r.width, h: r.height, x: d, y: m }, f }(this.currIndex, this.currItemData, this) } ci() { this.plugins = {}, this.pluginClasses && Object.keys(this.pluginClasses).forEach((t => { const i = this.pluginClasses[t]; "function" == typeof i && (this.plugins[t] = new i(this)) })) } ri(t) { window.matchMedia("(prefers-reduced-motion), (update: slow)").matches && (t.showHideAnimationType = "none", t.zoomAnimationDuration = 0), this.options = { ...U, ...t } } }
